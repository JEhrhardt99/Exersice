if (inherits(x, "htest"))
result <- c(x$statistic, x$p.value)
names(result) <- c("stat", "p-value")
round(result, 3)
}
#library("car")
lr.mxc <- lrtest(Train.mxlc, Train.ml) # LR test
wd.mxc <- waldtest(Train.mxlc) # Wald test
lh.mxc <- linearHypothesis(Train.mxlc,
c("chol.time:time = 0",
"chol.time:change =  0",
"chol.time:comfort = 0",
"chol.change:change = 0",
"chol.change:comfort = 0",
"chol.comfort:comfort = 0"))
sc.mxc <- scoretest(Train.ml,
rpar=c(time = "n", change = "n",comfort = "n"),
R = 100, correlation = TRUE, halton = NA,
panel = TRUE) # Score test
sapply(list(wald = wd.mxc, lh = lh.mxc,
score = sc.mxc, lr = lr.mxc),
statpval)
lr.corr <- lrtest(Train.mxlc, Train.mxlu)
lh.corr <- linearHypothesis(Train.mxlc,
c("chol.time:change = 0",
"chol.time:comfort = 0",
"chol.change:comfort = 0"))
wd.corr <- waldtest(Train.mxlc, correlation = FALSE)
sc.corr <- scoretest(Train.mxlu, correlation = TRUE)
sapply(list(wald = wd.corr, lh = lh.corr,
score = sc.corr, lr = lr.corr), statpval)
screenreg(list('MNL' = Train.ml,
'RC logit 1' = Train.mxlu),
stars = c(.01, .05, .10))
View(df)
?feols
??feols
?fixest
??fixest
??fixest
>
??fixest
install.packages("rgl")
install.packages("animation")
library(animation)
library(rgl)
# Install required packages if not installed
if (!requireNamespace("rgl", quietly = TRUE)) {
install.packages("rgl")
}
if (!requireNamespace("animation", quietly = TRUE)) {
install.packages("animation")
}
# Load required libraries
library(rgl)
library(animation)
# Define the multidimensional function
f <- function(x, y) {
return(sin(sqrt(x^2 + y^2)) / (sqrt(x^2 + y^2)))
}
# Generate data
x <- y <- seq(-5, 5, length.out = 100)
z <- outer(x, y, f)
# Create 3D plot
open3d()
rgl.surface(x, y, z, color = "viridis", alpha = 0.7, front = "lines", back = "lines")
# Install required packages if not installed
if (!requireNamespace("rgl", quietly = TRUE)) {
install.packages("rgl")
}
if (!requireNamespace("animation", quietly = TRUE)) {
install.packages("animation")
}
# Load required libraries
library(rgl)
library(animation)
# Define the multidimensional function
f <- function(x, y) {
return(sin(sqrt(x^2 + y^2)) / (sqrt(x^2 + y^2)))
}
# Generate data
x <- y <- seq(-5, 5, length.out = 100)
z <- outer(x, y, f)
# Create 3D plot
open3d()
surface3d(x, y, z, color = terrain.colors(100), alpha = 0.7, front = "lines", back = "lines")
# Add labels and title
rgl.texts(x = 0, y = 0, z = max(z), texts = "Multidimensional Function", adj = c(-0.5, 0.5), cex = 1.5, col = "red")
(120 * 0.3) + (-160 * 0.7)
0.3*200
View(df)
2*(200+170+170+(0.5*60)+(0.5*120))
2*(200+170+170+(0.5*60)-(0.5*120))
knitr::opts_chunk$set(echo = TRUE)
#Converted to R in May/October 2021 using RStudio Version 1.4.1106
rm(list=ls())
#Load libraries
library(AER) #for ivreg
#Load libraries
library(AER) #for ivreg
library(fixest) #for feols etc
library(haven) #for read_dta
library(modelsummary) #for neat tables
library(fixest) #for feols etc
library(haven) #for read_dta
library(modelsummary) #for neat tables
library(tidyverse)
## Set working directory
#Specify the access path to the computer folder you will use for the analysis
#setwd("INSERT PATH TO PROJECT FOLDER WITH / or \\")
setwd("~/Desktop/Applied_Economics_and_Data_Science/Courses/WiSe_23_24/Econometrics_of_Policy_Evaluation/2023-12-19/Lab")
rm(list=ls())
## open data
#Open the cleaned data set
#set path for data
evaluation <- file.path(getwd(), "evaluation.dta")
#import .dta file
evaluation.df <- read_dta(evaluation)
#Select the relevant data
iv.df <- subset(evaluation.df, select = -eligible)
ex5_lm <- lm(health_expenditures ~ treatment_locality, round == 1, data = iv.df)
models <- list("ex5_lm" = ex5_lm)
modelsummary(models,
vcov = ~ locality_identifier,
stars = c("*" = .1, "**" = .05, "***" = .01),
fmt = 3,
gof_omit = "AIC|BIC|Log.Lik.|R2 Adj.|R2 Within|R2 Pseudo|F")
?ivreg
ex6_iv <- ivreg(health_expenditures ~ enrolled | treatment_locality,
data = subset(iv.df, round == 1))
models <- list("ex6_iv" = ex6_iv)
modelsummary(models,
vcov = ~ locality_identifier,
stars = c("*" = .1, "**" = .05, "***" = .01),
fmt = 3,
gof_omit = "AIC|BIC|Log.Lik.|R2 Adj.|R2 Within|R2 Pseudo|F")
#display first-stage (manually)
ex6_iv_s1 <- lm(enrolled ~ treatment_locality, data = subset(iv.df, round == 1))
models <- list("ex6_iv_s1" = ex6_iv_s1)
modelsummary(models,
vcov = ~ locality_identifier,
stars = c("*" = .1, "**" = .05, "***" = .01),
fmt = 3,
gof_omit = "AIC|BIC|Log.Lik.|R2 Adj.|R2 Within|R2 Pseudo")
#Check objects in data.frame -- note *.*_rp variables
objects(evaluation.df)
#Select the relevant data, drop what not needed
rp.df <- subset(evaluation.df, select = c(-eligible, -treatment_locality, -enrolled))
#second-stage
ex7_iv <- ivreg(health_expenditures ~ enrolled_rp | promotion_locality,
data = subset(rp.df, round == 1))
models <- list("ex7_iv" = ex7_iv)
modelsummary(models,
vcov = ~ locality_identifier,
stars = c("*" = .1, "**" = .05, "***" = .01),
fmt = 3,
gof_omit = "AIC|BIC|Log.Lik.|R2 Adj.|R2 Within|R2 Pseudo")
#display first stage
ex7_iv_s1 <- lm(enrolled_rp ~ promotion_locality, data = subset(rp.df, round == 1))
models <- list("ex7_iv_s1" = ex7_iv_s1)
modelsummary(models,
vcov = ~ locality_identifier,
stars = c("*" = .1, "**" = .05, "***" = .01),
fmt = 3,
gof_omit = "AIC|BIC|Log.Lik.|R2 Adj.|R2 Within|R2 Pseudo")
#you could also use a multivariate regression
#note: exogenous regressors have to be included as instruments for themselves
ex7_mv <- ivreg(health_expenditures ~ enrolled_rp + age_hh + age_sp +
educ_hh + educ_sp + female_hh + indigenous +
hhsize + dirtfloor + bathroom + land + hospital_distance |
promotion_locality + age_hh + age_sp + educ_hh + educ_sp +
female_hh + indigenous + hhsize + dirtfloor + bathroom + land +
hospital_distance,
data = subset(rp.df, round == 1))
models <- list("ex7_mv" = ex7_mv)
modelsummary(models,
vcov = ~ locality_identifier,
stars = c("*" = .1, "**" = .05, "***" = .01),
fmt = 3,
gof_omit = "AIC|BIC|Log.Lik.|R2 Adj.|R2 Within|R2 Pseudo")
#first stage
ex7_mv_s1 <- lm(enrolled_rp ~ promotion_locality +
age_hh + age_sp + educ_hh + educ_sp + female_hh +
indigenous + hhsize + dirtfloor + bathroom + land + hospital_distance,
data = subset(rp.df, round == 1))
models <- list("ex7_mv_s1" = ex7_mv_s1)
modelsummary(models,
vcov = ~ locality_identifier,
stars = c("*" = .1, "**" = .05, "***" = .01),
fmt = 3,
gof_omit = "AIC|BIC|Log.Lik.|R2 Adj.|R2 Within|R2 Pseudo")
2^7
knitr::opts_chunk$set(echo = TRUE)
ggplot(target_group_market_share, aes(x = cust_sgmnt, y = sum_market_share, fill = cust_sgmnt)) +
geom_bar(stat = "identity") +
labs(title = "Market Shares by Target Groups",
x = "Customer Segment",
y = expression(paste(sum(), " Market Shares in %")),
fill = "Target Groups") +
theme_few() +
theme(axis.text.x = element_text(angle = 0.1, hjust = 0.5),
plot.title = element_text(hjust = 0.5))  # Rotate x-axis labels for better readability
knitr::opts_chunk$set(echo = TRUE)
# clear environment
rm(list = ls())
# get packages
library(pacman)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(haven, forecast, fpp3, fpp2, dplyr,
lubridate, stargazer, modelsummary,
estimatr, ggplot2, ggthemes, tidyverse,
DescTools, zoo, xts, plm, data.table,
Hmisc, expss, lmtest, sandwich, AER,
knitr, mlogit, car, texreg, openxlsx,
reshape2, readxl, fixest, dfidx, tidyr,
data.table, kableExtra, knitr, fread, stringr)
# or
# install.packages("XXX")
# library(XXX)
## Set working directory
current_rmd <- rstudioapi::getSourceEditorContext()$path
# Set the working directory to the location of the R Markdown file
setwd(dirname(current_rmd))
data_path <- file.path(getwd(), "data/Cereal_Data.xls")
data <- data.frame(read_xls(data_path))
# some adjustments for smooth workflow:
# variable mapping for renaming them
variable_mapping <- c(
oID = "X0",
name_product = "Name",
avg_trans_price = "Avg.Trans.Price",
avg_shelf_price = "Avg.Shelf.Price",
avg_advert_exp = "Avg.Ad.Expn",
naive_market_share = "Mkt.Share",
cust_sgmnt = "Sgmnt",
calories = "Cals",
fat = "Fat",
sugar = "Sugar"
)
data <- data %>%
rename(!!!variable_mapping)
### include labels for better understanding of the variables ###
label(data$oID) <- "Unique observation identifier"
label(data$name_product) <- "Name of the product" # Note that some brands have multiple products -> analyse structure!
label(data$avg_trans_price) <- "Average transaction price" ### differnece to shelf price???
label(data$avg_shelf_price) <- "Average shelf price" ### differnece to transaction price???
label(data$avg_advert_exp) <- "Average expenditures on advertisement" # sounds like a nice instrument (later)
label(data$naive_market_share) <- "Market share of the product in percent"
label(data$cust_sgmnt) <- "Targeted customer segment"
label(data$calories) <- "Calories (characteristic)"
label(data$fat) <- "Fat (characteristic)"
label(data$sugar) <- "Sugar (characteristic)"
### some data exploration ###
# check data types #
# str(data)
# sapply(data, class)
# no further processing needed
grouped_data <- data %>%
group_by(cust_sgmnt) %>%
summarise(count = n())
# print(grouped_data)
ggplot(grouped_data, aes(x = cust_sgmnt, y = count)) +
geom_bar(stat = "identity") +
theme_few() +
labs(title = "Counts of each customer segment",
x = "Customer Segment",
y = "Count") +
theme(plot.title = element_text(hjust = 0.5))
# Extract brand information using regular expressions (pattern of the variable name_product allows this)
data <- data %>%
mutate(brand = str_extract(name_product, "^[A-Z]{2}"))
# Check the unique brands and their counts
brand_counts <- data %>%
group_by(brand) %>%
summarise(count = n()) %>%
arrange(desc(count))
# Display the brand counts
# print(brand_counts)
# Plot a bar chart to visualize the brand counts
ggplot(brand_counts, aes(x = brand, y = count)) +
theme_few() +
geom_bar(stat = "identity") +
labs(title = "Counts of products by brand",
x = "Brand",
y = "Count") +
theme(plot.title = element_text(hjust = 0.5))
# Calculate (very) naive market shares by brand (excluding unidentified brands which had a share of ca 25%)
naive_market_share <- data %>%
group_by(brand) %>%
summarise(naive_market_share = n() / nrow(data)) # this might be unwise to do... we will need to model outside options and here, other brands are excluded
# Display the market shares
# print(naive_market_share)
# Plot a bar chart to visualize market shares
ggplot(naive_market_share, aes(x = brand, y = naive_market_share)) +
geom_bar(stat = "identity") +
theme_few() +
labs(title = "Market shares by brand",
x = "Brand",
y = "(very) naive Market Share") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.title = element_text(hjust = 0.5))
# Find out how many different products each brand has in each customer segment
brand_product_count <- data %>%
group_by(brand, cust_sgmnt) %>%
summarise(unique_products = n_distinct(name_product))
brand_product_count <- brand_product_count %>%
rename("Brand" = brand,
"Customer Segment" = cust_sgmnt,
"Unique Products Count" = unique_products)
# Display the result
knitr::kable(brand_product_count,
format = "latex",
col.names = c("Brand", "Customer Segment", "Unique Products Count"),
caption = "Summary of Unique Products Count by Brand and Customer Segment.",
booktabs = TRUE) %>%
kable_styling(bootstrap_options = "striped", font_size = 7)
# Create dataframes which contain a subset for each customer segment
df_adult <- subset(data,
grepl("Adult", cust_sgmnt))
df_fam <- subset(data,
grepl("Fam", cust_sgmnt))
df_kids <- subset(data,
grepl("Kids", cust_sgmnt))
# prepare a table that shows the brand count for each customer segment
brand_segment_table <- table(data$cust_sgmnt, data$brand)
# as dataframe:
brand_segment_df <- data.frame(
Segment = c("Adult", "Fam", "Kids"),
GM = c(6, 6, 6),
KG = c(9, 6, 2),
NB = c(3, 0, 0),
PT = c(3, 1, 2),
QK = c(2, 0, 2),
RL = c(2, 0, 0)
)
# Add row sums
brand_segment_df$Total <- rowSums(brand_segment_df[, 2:7])
# Add column sums and the total sum (50) which is the number of observations of the original dataframe minus the observation "basket of all other brands"
brand_segment_df <- rbind(
brand_segment_df,
c("Total", colSums(brand_segment_df[, 2:7]), 50)
)
# Convert the table to a data frame
#brand_segment_df <- as.data.frame(brand_segment_table)
kable(brand_segment_df,
format = "markdown",
caption = "Product Count of each Brand per Segment",
booktabs = TRUE) %>%
kable_styling(bootstrap_options = "striped", font_size = 7)
# overwrite brand_segment_table in wanted format
brand_segment_table <- data.frame(
Segment = c("Adult", "Fam", "Kids"),
GM = c(6, 6, 6),
KG = c(9, 6, 2),
NB = c(3, 0, 0),
PT = c(3, 1, 2),
QK = c(2, 0, 2),
RL = c(2, 0, 0)
)
# Reshape the data for plotting
brand_segment_table_long <- tidyr::gather(brand_segment_table, key = "Brand", value = "Count", -Segment)
# Plot using ggplot2
ggplot(brand_segment_table_long, aes(x = Segment, y = Count, fill = Brand)) +
geom_bar(stat = "identity", position = "stack", color = "white") +
labs(x = "Target Group",
y = "Product Count") +
theme_few()
# Display cumulated market shares of target groups
target_group_market_share <- data %>%
group_by(cust_sgmnt) %>%
summarise(sum_market_share = sum(naive_market_share))
# replace NA with string
target_group_market_share <- target_group_market_share %>%
mutate(cust_sgmnt = if_else(is.na(cust_sgmnt),
'Other Brands',
as.character(cust_sgmnt)))
# Display cumulated market shares of brands
brand_market_share <- data %>%
group_by(brand) %>%
summarise(cumulated_market_share = sum(naive_market_share))
# replace NA with string
brand_market_share <- brand_market_share %>%
mutate(brand = if_else(is.na(brand),
'Other Brands',
as.character(brand)))
ggplot(target_group_market_share, aes(x = cust_sgmnt, y = sum_market_share, fill = cust_sgmnt)) +
geom_bar(stat = "identity") +
labs(title = "Market Shares by Target Groups",
x = "Customer Segment",
y = expression(paste(sum(), " Market Shares in %")),
fill = "Target Groups") +
theme_few() +
theme(axis.text.x = element_text(angle = 0.1, hjust = 0.5),
plot.title = element_text(hjust = 0.5))  # Rotate x-axis labels for better readability
1 + 1
1 + 1
library(tidyverse)
ggplot(diamonds, aes(x = cut)) +
geom_bar()
ggplot(diamonds, aes(x = cut)) +
geom_bar()
install.packages("reticulate")
reticulate::repl_python()
library(gt)
library(gt)
head(mtcars_new) %>% gt()
mtcars_new <- py$mtcars_py
head(mtcars_new) %>% gt()
mtcars_new
library(gt)
install.packages(gt)
install.packages("gt")
install.packages("gt")
?head
head(mtcars_new, n=3)
mtcars_new <- py$mtcars_py
reticulate::repl_python()
library(reticulate) # needed to  get data from python to r
library(gt)
library(dplyr)
mtcars_new <- py$mtcars_py
head(mtcars_new, n=3)
reticulate::repl_python()
library(reticulate) # needed to  get data from python to r
library(gt)
library(dplyr)
mtcars_new <- py$mtcars_py
mtcars_new <- data.frame(mtcars_new)
head(mtcars_new) %>% gt()
ggplot(diamonds, aes(x = cut)) +
geom_bar()
#| label: load packages
#| echo: true
#| label: load packages
#| echo: true
#| output: false
library(tidyverse)
#| label: fig-diamonds
#| fig-cap: "A bar chart of diamonds cuts"
#| label: fig-diamonds
#| fig-cap: "A bar chart of diamonds cuts"
#| fig-alt: |
#|    "more descriptive stuff"
#| out-width: 50%
#| code-fold: true
ggplot(diamonds, aes(x = cut)) +
geom_bar()
# Laden der erforderlichen Bibliotheken
library(ggplot2)
# Erzeugen von Daten für die Plots
X_values <- seq(0, 9000, by = 10)  # Erstelle eine Sequenz von X-Werten
supply_price <- (X_values) / 2  # Berechne den Angebotspreis
demand_price <- (6000 - X_values) / 6  # Berechne den Nachfragepreis
demand_pricesub <- (9000 - X_values)/6 # Berechne subventionierter Preis
# Erstellen eines Dataframes für ggplot2
data <- data.frame(X = X_values,
SupplyPrice = supply_price,
DemandPrice = demand_price,
DemandPricesub = demand_pricesub)
# Erstellen des Plots
ggplot(data, aes(x = X)) +
geom_line(aes(y = SupplyPrice, colour = "Supply"), size = 1) +
geom_line(aes(y=demand_price, colour = "Demand"), size = 1) +
geom_line(aes(y = DemandPricesub, colour = "Subsidy"), size = 1) +
labs(x = "Menge", y = "Preis", title = "Angebots- und Nachfragekurven") +
scale_color_manual(name = "Kurve",
values = c("Supply" = "blue", "Demand" = "red", "Subsidy" = "green"),
labels = c("Nachfrage","Subsidy","Angebot")) +
theme_minimal()
# Gleichsetzen der Angebots- und Nachfragefunktionen und Auflösen nach p
# 2p = 6000 - 6p
# 8p = 6000
# p = 9000 / 8
equilibrium_price <- 6000 / 8
equilibrium_pricesub <- 9000 / 8
# Berechnen der Gleichgewichtsmenge
# X = 2p beim Gleichgewichtspreis
equilibrium_quantity <- 2 * equilibrium_price
equilibrium_quantitysub <- 2 * equilibrium_pricesub
nachfrager <- 6000 - 6*(4000/6)
# clear global environment
rm(list = ls())
library(tidyverse)
library(estimatr)
library(modelsummary)
library(visdat)
library(dplyr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set working directory to script location
setwd("../..") # move up to the project root directory
getwd() # check if wd is the root directory
df_STAN <- read.csv("main/Data_sets/STAN_ALL.csv")
df_small <- df_STAN[c("COUNTRY",
"YEAR",
"VALU",
"WAGE",
"INDUSTRY",
"ISICREV3")]
vis_dat(df_small)
df_small <- df_small[order(df_small$COUNTRY, df_small$INDUSTRY, df_small$YEAR),]
df_small <- df_small %>%
group_by(COUNTRY, INDUSTRY) %>%
mutate(idnr = group_indices())
df_small <- df_small %>%
group_by(idnr) %>%
mutate(VALU_lag_1 = dplyr::lag(VALU, n = 1L, default = NA,))
df_small$VALU_gr <- (df_small$VALU - df_small$VALU_lag_1)/df_small$VALU_lag_1
df_small <- df_small %>%
group_by(idnr) %>%
mutate(WAGE_lag_1 = dplyr::lag(WAGE, n = 1L, default = NA,))
df_small$WAGE_gr <- (df_small$WAGE - df_small$WAGE_lag_1)/df_small$WAGE_lag_1
View(df_small)
vis_dat(df_small)
